# Nutrition Tracker MVP - Project Scaffolding Steps

This file contains the step-by-step prompts generated by ChatGPT in research mode to scaffold this codebase ([chat link](https://chatgpt.com/share/681785d2-d518-8001-bbb2-b4452d04be3e)). These steps outline the structure, implementation details, and testing approach for building the application. The project leverages Python, Flask, SQLite, JSON, and Jinja2 templates, with a focus on modularity and maintainability. For inspiration and best practices, references were taken from vibe-coding patterns in the network.

---

## Step 1 – Project Skeleton

Create a Python project folder structure for a “nutrition-tracker-mvp” with these items and placeholder comments in each:

```plaintext
• config.yaml
• openapi.yaml
• app.py
• storage_manager.py
• reports.py
• templates/ (containing daily_report.html and weekly_report.html)
• static/ (containing index.html)
• data/ (empty)
• tests/ (containing test_storage.py)
```

---

## Step 2 – OpenAPI Spec

Create an OpenAPI 3.0.0 spec file named `openapi.yaml` that defines these endpoints:

```plaintext
• POST /addEntry
• GET /showDaily
• GET /showSummary
• GET /getDailyReport
• GET /getWeeklyReport
• POST /deleteEntry
• POST /flushEntries
```

---

## Step 3 – Config Loader

In `config.yaml`, define:

```yaml
storage:
  primary: sqlite
  secondary: json
sqlite:
  path: data/nutrition.db
json:
  base_dir: data/json
  mode: per_day
```

Then write `config.py` that loads this YAML into a `Config` class (using PyYAML or pydantic) with attributes `storage.primary`, `sqlite.path`, `json.base_dir`, and `json.mode`.

---

## Step 4 – StorageManager Abstraction

In `storage_manager.py`, define a class `StorageManager` whose `__init__` reads `Config` and instantiates `SQLiteBackend(sqlite_path)` and `JSONBackend(base_dir, mode)`. Add methods:

```python
add_entry(entry)
get_entries(start, end)
delete_entries(date)
flush_entries()
get_daily_summary(date)
get_weekly_summary(start, end)
```

Implement `add_entry()` to call `primary.add_entry(...)` then `secondary.add_entry(...)` with error handling, and leave the other methods as stubs raising `NotImplementedError`.

---

## Step 5 – SQLiteBackend Implementation

Still in `storage_manager.py`, implement a class `SQLiteBackend` with:

```python
class SQLiteBackend:
    def __init__(self, db_path):
        # Open sqlite3 connection and create table
        pass

    def add_entry(self, entry):
        # INSERT into entries
        pass

    def get_entries(self, start, end):
        # SELECT rows between dates
        pass

    def delete_entries(self, date):
        # DELETE rows where date(timestamp)=?
        pass

    def flush_entries(self):
        # DELETE all rows
        pass

    def get_daily_summary(self, date):
        # SELECT SUM(...) GROUP BY date(timestamp)
        pass

    def get_weekly_summary(self, start, end):
        # Same over date range
        pass
```

Use parameterized queries and `conn.commit()`.

---

## Step 6 – JSONBackend Implementation

In `storage_manager.py`, also implement a class `JSONBackend` with methods:

```python
class JSONBackend:
    def __init__(self, base_dir, mode):
        # Ensure base_dir exists
        pass

    def add_entry(self, entry):
        # Write or append per-day or per-week JSON files based on mode
        pass

    def get_entries(self, start, end):
        # Read and combine JSON files for the range
        pass

    def delete_entries(self, date):
        # Delete that date’s JSON file
        pass

    def flush_entries(self):
        # Remove all JSON files
        pass

    def get_daily_summary(self, date):
        # Aggregate JSON data
        pass

    def get_weekly_summary(self, start, end):
        # Aggregate JSON data
        pass
```

---

## Step 7 – Flask Routes and OpenAPI Stubs

In `app.py`, import `Flask`, `request`, `jsonify`, and `render_template`. Load `Config` and instantiate `StorageManager`. Define a decorator `@require_api_key` to check the API key header. Create routes matching `openapi.yaml`:

```python
POST /addEntry
GET /showDaily
GET /showSummary
GET /getDailyReport
GET /getWeeklyReport
POST /deleteEntry
POST /flushEntries
```

In each handler, call `StorageManager` or `reports.py` as appropriate. Protect all routes with `@require_api_key`.

---

## Step 8 – Report Templates

In `templates/daily_report.html`, write a Jinja2 template that:

- Shows the date as a header.
- Loops over entries (showing time, description, calories, protein, etc.).
- Displays totals versus hard-coded goals.

In `templates/weekly_report.html`, write a template that:

- Loops over each day’s summary in a table.
- Color-codes cells based on goal attainment.

---

## Step 9 – Minimal Front-End

In `static/index.html`, create an HTML+JavaScript page that:

- Prompts the user for the API key on load.
- Provides a form to `POST /addEntry` (fields: timestamp, description, calories, protein, carbs, fat, caffeine).
- Has controls (buttons or forms) to call `GET /showDaily`, `/showSummary`, `/getDailyReport`, and `/getWeeklyReport`—rendering the JSON or HTML responses into the page.
- Injects the API key into fetch headers automatically.

---

## Step 10 – Add Tests

In `tests/test_storage.py`, write `pytest` tests for `StorageManager` using a temporary SQLite file and temp JSON directory:

```python
def test_add_and_get_entries():
    # Add entries, fetch by range, assert counts
    pass

def test_delete_and_flush():
    # Delete a date’s entries, flush all, assert no entries remain
    pass

def test_daily_and_weekly_summary():
    # Add entries on multiple dates, assert summary totals match expected sums
    pass
```
